<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>口阿岂几的blog</title>
  
  <subtitle>一个写着写着就越来越多的blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.zhengwenkai.com/"/>
  <updated>2019-09-06T05:26:04.273Z</updated>
  <id>http://www.zhengwenkai.com/</id>
  
  <author>
    <name>zhengwkai@gmail.com</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>encoding/json -- 标准库中的包</title>
    <link href="http://www.zhengwenkai.com/2019/09/06/golang_json/"/>
    <id>http://www.zhengwenkai.com/2019/09/06/golang_json/</id>
    <published>2019-09-05T21:09:30.000Z</published>
    <updated>2019-09-06T05:26:04.273Z</updated>
    
    <content type="html"><![CDATA[<h1 id="encoding-json-–-标准库中的包"><a href="#encoding-json-–-标准库中的包" class="headerlink" title="encoding/json – 标准库中的包"></a>encoding/json – 标准库中的包</h1><h3 id="func-Marshal"><a href="#func-Marshal" class="headerlink" title="func Marshal"></a><strong>func Marshal</strong></h3><pre><code>func Marshal(v interface{}) ([]byte, error)</code></pre><p><strong>Marshal returns the JSON encoding of v.</strong></p><p>Marshal traverses the value v recursively.（Marshal 递归的遍历v值）</p><p>If an encountered value implements the Marshaler interface and is not a nil pointer （如果遇到一个实现Marshaler interface 并且不是一个空指针的值）Marshal calls its MarshalJSON method to produce JSON.</p><p>If no MarshalJSON method is present but the value implements encoding.TextMarshaler instead,(如果不存在MarshalJSON 方法,但是value实现encoding.TextMarshaler) Marshal calls its MarshalText method and encodes the result as a JSON string. (则Marshal调用其MarshalText方法并将结果编码为JSON字符串)</p><p>The nil pointer exception is not strictly necessary but mimics a similar, necessary exception in the behavior of UnmarshalJSON. (空指针异常不是绝对必要的，但是在UnmarshalJSON方法的行为中模仿了类似的必要异常)</p><p>Otherwise, Marshal uses the following type-dependent default encodings:</p><p>另外Marshal 使用如下类型相关的默认编码</p><p>Boolean values encode as JSON booleans.</p><p>Floating point, integer, and Number values encode as JSON numbers.</p><p>String values encode as JSON strings coerced to valid UTF-8, </p><p>字符串值编码为强制为有效UTF-8的JSON字符串</p><p>replacing invalid bytes with the Unicode replacement rune. </p><p>用Unicode replacement rune替换无效的字节</p><p>The angle brackets “&lt;” and “&gt;” are escaped to “\u003c” and “\u003e” to keep some browsers from misinterpreting JSON output as HTML. </p><p>尖括号“&lt;”和“&gt;”被转义为“\ u003c”和“\ u003e” 以防止某些浏览器将JSON输出误解为HTML</p><p>Ampersand “&amp;” is also escaped to “\u0026” for the same reason.</p><p>同样的Ampersand “&amp;” 也被转义为”\u0026”</p><p> This escaping can be disabled using an Encoder that had SetEscapeHTML(false) called on it.</p><p>可以使用调用了SetEscapeHTML（false）的编码器禁用此转义</p><p>Array and slice values encode as JSON arrays, except that []byte encodes as a base64-encoded string, and a nil slice encodes as the null JSON value.</p><p>数组和切片值编码为JSON数组，但[]字节编码为base64编码的字符串，而nil切片编码为空JSON对象。</p><p>Struct values encode as JSON objects. Each exported struct field becomes a member of the object, using the field name as the object key, unless the field is omitted for one of the reasons given below.</p><p>结构体的值编码为JSON对象。每个导出的struct字段都成为对象的成员，使用字段名作为对象键,</p><p>除非出于下面给出的原因，省略该字段</p><p>The encoding of each struct field can be customized by the format string stored under the “json” key in the struct field’s tag. </p><p>每个结构字段的编码可以通过存储在struct字段标记中的“json”键下的格式字符串来定制</p><p>The format string gives the name of the field, possibly followed by a comma-separated list of options.</p><p>格式字符串给出了字段的名称，可能后跟逗号分隔的选项列表。</p><p>The name may be empty in order to specify options without overriding the default field name.</p><p>名称可以为空，以便指定选项而不覆盖默认字段名称。</p><p>The “omitempty” option specifies that the field should be omitted from the encoding if the field has an empty value, defined as false, 0, a nil pointer, a nil interface value, and any empty array, slice, map, or string.</p><p>“omitempty”选项指定如果字段是空值(被定义为false, 0 , nil指针，nil接口以及任何空数组、切片、map、字符串等)，则应从编码中省略该字段</p><p>As a special case, if the field tag is “-“, the field is always omitted. Note that a field with name “-“ can still be generated using the tag “-,”.</p><p>Examples of struct field tags and their meanings:</p><pre><code>package mainimport (    &quot;encoding/json&quot;    &quot;fmt&quot;    &quot;os&quot;)func main() {    type ColorGroup struct {        ID     int        Name   string        Colors []string    }    group := ColorGroup{        ID:     1,        Name:   &quot;Reds&quot;,        Colors: []string{&quot;Crimson&quot;, &quot;Red&quot;, &quot;Ruby&quot;, &quot;Maroon&quot;},    }    b, err := json.Marshal(group)    if err != nil {        fmt.Println(&quot;error:&quot;, err)    }    os.Stdout.Write(b)}// Field appears in JSON as key &quot;myName&quot;.Name string `json:&quot;MyName&quot;`// output//{&quot;ID&quot;:1,&quot;MyName&quot;:&quot;Reds&quot;,&quot;Colors&quot;:[&quot;Crimson&quot;,&quot;Red&quot;,&quot;Ruby&quot;,&quot;Maroon&quot;]}// Field appears in JSON as key &quot;myName&quot; and// the field is omitted from the object if its value is empty,// as defined above.Name string `json:&quot;MyName,omitempty&quot;`// 将上面Name: &quot;Reds&quot; =&gt; Name: &quot;&quot;// output, 由于使用了omitempty选项，MyName字段被忽略掉// {&quot;ID&quot;:1,&quot;Colors&quot;:[&quot;Crimson&quot;,&quot;Red&quot;,&quot;Ruby&quot;,&quot;Maroon&quot;]}// Field appears in JSON as key &quot;Field&quot; (the default), but// the field is skipped if empty.// Note the leading comma.Name string `json:&quot;,omitempty&quot;`// 将上面Name: &quot;Reds&quot; =&gt; Name: &quot;&quot;//{&quot;ID&quot;:1,&quot;Colors&quot;:[&quot;Crimson&quot;,&quot;Red&quot;,&quot;Ruby&quot;,&quot;Maroon&quot;]}// Field is ignored by this package.//忽略字段Name string `json:&quot;-&quot;`// {&quot;ID&quot;:1,&quot;Colors&quot;:[&quot;Crimson&quot;,&quot;Red&quot;,&quot;Ruby&quot;,&quot;Maroon&quot;]}// Field appears in JSON as key &quot;-&quot;.Name string `json:&quot;-,&quot;`// {&quot;ID&quot;:1,&quot;-&quot;:&quot;Reds&quot;,&quot;Colors&quot;:[&quot;Crimson&quot;,&quot;Red&quot;,&quot;Ruby&quot;,&quot;Maroon&quot;]}</code></pre><p>The “string” option signals that a field is stored as JSON inside a JSON-encoded string. It applies only to fields of string, floating point, integer, or boolean types. This extra level of encoding is sometimes used when communicating with JavaScript programs:</p><p>“string”选项表示字段在JSON编码的字符串中存储为JSON。 它仅适用于字符串，浮点，整数或布尔类型的字段。 在与JavaScript程序通信时，有时会使用这种额外的编码级别：</p><pre><code>ID int `json:&quot;,string&quot;`//仍然使用上面的例子// 可以看到ID转为&quot;1&quot;//{&quot;ID&quot;:&quot;1&quot;,&quot;Name&quot;:&quot;Reds&quot;,&quot;Colors&quot;:[&quot;Crimson&quot;,&quot;Red&quot;,&quot;Ruby&quot;,&quot;Maroon&quot;]}</code></pre><p>The key name will be used if it’s a non-empty string consisting of only Unicode letters, digits, and ASCII punctuation except quotation marks, backslash, and comma.</p><p>如果字段名称是只包含Unicode字母，数字和ASCII标点符号（引号，反斜杠和逗号除外） 的非空字符串，则该字段名将被使用</p><p>Anonymous struct fields are usually marshaled as if their inner exported fields were fields in the outer struct, subject to the usual Go visibility rules amended as described in the next paragraph.An anonymous struct field with a name given in its JSON tag is treated as having that name, rather than being anonymous.An anonymous struct field of interface type is treated the same as having that type as its name, rather than being anonymous</p><p>匿名结构体字段通常会被编码，就好像它们内部导出的字段是外部结构中的字段一样，受到通常的Go可见性规则的限制，如下一段所述。在其JSON标记中给出名称的匿名结构字段被视为具有该名称，而不是匿名。 接口类型的匿名结构字段的处理方式与将该类型作为其名称相同，而不是匿名。</p><pre><code>//将上面的例子改造一下，ColorGroup 增加一个匿名结构体 Rgbtype Rgb struct {    R, G, B int}type ColorGroup struct {        ID     int `json:&quot;,string&quot;`        Name   string        Colors []string        Rgb // 匿名结构体}group := ColorGroup{        1,        &quot;Reds&quot;,        []string{&quot;Crimson&quot;, &quot;Red&quot;, &quot;Ruby&quot;, &quot;Maroon&quot;},        Rgb{50, 50, 50},}// output//{&quot;ID&quot;:&quot;1&quot;,&quot;Name&quot;:&quot;Reds&quot;,&quot;Colors&quot;:[&quot;Crimson&quot;,&quot;Red&quot;,&quot;Ruby&quot;,&quot;Maroon&quot;],&quot;R&quot;:50,&quot;G&quot;:50,&quot;B&quot;:50}type ColorGroup struct {        ID     int `json:&quot;,string&quot;`        Name   string        Colors []string        Rgb `json:&quot;rgb&quot;` // json 重命名选项 }// {&quot;ID&quot;:&quot;1&quot;,&quot;Name&quot;:&quot;Reds&quot;,&quot;Colors&quot;:[&quot;Crimson&quot;,&quot;Red&quot;,&quot;Ruby&quot;,&quot;Maroon&quot;],&quot;rgb&quot;:{&quot;R&quot;:50,&quot;G&quot;:50,&quot;B&quot;:50}}</code></pre><p>The Go visibility rules for struct fields are amended for JSON when deciding which field to marshal or unmarshal. If there are multiple fields at the same level, and that level is the least nested (and would therefore be the nesting level selected by the usual Go rules), the following extra rules apply:</p>]]></content>
    
    <summary type="html">
    
      golang, json
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>NodeJS--path.resolve</title>
    <link href="http://www.zhengwenkai.com/2019/08/02/nodejs_path_resolve/"/>
    <id>http://www.zhengwenkai.com/2019/08/02/nodejs_path_resolve/</id>
    <published>2019-08-02T02:31:36.000Z</published>
    <updated>2019-08-02T10:59:50.411Z</updated>
    
    <content type="html"><![CDATA[<h1 id="path-resolve"><a href="#path-resolve" class="headerlink" title="path.resolve"></a>path.resolve</h1><h3 id="path-resolve-…paths"><a href="#path-resolve-…paths" class="headerlink" title="path.resolve([…paths])"></a>path.resolve([…paths])</h3><ul><li>…paths <string> A sequence of paths or path segments (一系列的路径 or 路径片段)</string></li><li>Returns: <string> absolute path (函数返回绝对路径).</string></li></ul><p>The <strong>path.resolve()</strong> method resolves a sequence of paths or path segments into an absolute path.</p><p>The given sequence of paths is processed from right to left （给定的路径被从右往左处理，直到构建出一个绝对路径）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">path.resolve(&apos;/foo&apos;, &apos;/bar&apos;, &apos;baz&apos;)  </span><br><span class="line">// 返回 /bar/baz</span><br><span class="line"></span><br><span class="line">path.resolve(&apos;/foo/bar&apos;, &apos;/tmp/file/&apos;);</span><br><span class="line">// 返回: &apos;/tmp/file&apos;</span><br></pre></td></tr></table></figure><p>If after processing all given path segments an absolute path has not yet been generated, the current working directory is used</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">path.resolve(&apos;wwwroot&apos;, &apos;static_files/png/&apos;, &apos;../gif/image.gif&apos;);</span><br><span class="line">// 如果当前工作目录为 /home/myself/node，</span><br><span class="line">// 则返回 &apos;/home/myself/node/wwwroot/static_files/gif/image.gif&apos;</span><br></pre></td></tr></table></figure><p>The resulting path is normalized and trailing slashes are removed unless the path is resolved to the root directory。 结果路径已被规范化并移除尾部斜杠，除非被解析为根目录</p><p>Zero-length path segments are ignored.</p><p>If no path segments are passed, path.resolve() will return the absolute path of the current working directory.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">path.resolve(&apos;&apos;)</span><br><span class="line">path.resolve()</span><br><span class="line">// /home/xxx  current working directory</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      NodeJS, path, resolve。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>WebRTC学习</title>
    <link href="http://www.zhengwenkai.com/2019/07/12/webRTC/"/>
    <id>http://www.zhengwenkai.com/2019/07/12/webRTC/</id>
    <published>2019-07-12T05:25:58.623Z</published>
    <updated>2019-07-12T06:04:21.362Z</updated>
    
    <content type="html"><![CDATA[<h4 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h4><ul><li><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API," title="Api" target="_blank" rel="noopener">API文档</a></p></li><li><p><a href="https://webrtc.github.io/samples/," title="sample" target="_blank" rel="noopener">Sample</a></p></li><li><p><a href="https://github.com/rtcweb-wg/mdns-ice-candidates" target="_blank" rel="noopener">mdns-ice-candidates</a></p><ul><li><a href="https://rtcweb-wg.github.io/mdns-ice-candidates/draft-ietf-rtcweb-mdns-ice-candidates.html#rfc.section.5.4" target="_blank" rel="noopener">Using Multicast DNS to protect privacy when exposing ICE candidates</a></li></ul></li><li><p><a href="https://bugs.webkit.org/show_bug.cgi?id=183201" target="_blank" rel="noopener">Support WebRTC in Safari in-app browser</a></p></li></ul><h4 id="什么是WebRTC"><a href="#什么是WebRTC" class="headerlink" title="什么是WebRTC"></a>什么是WebRTC</h4><blockquote><p>WebRTC，名称源自网页即时通信（英语：Web Real-Time Communication）的缩写，是一个支持网页浏览器进行实时语音对话或视频对话的API。</p></blockquote><h4 id="获取内网ip实验"><a href="#获取内网ip实验" class="headerlink" title="获取内网ip实验"></a>获取内网ip实验</h4><blockquote><p>WebRTC 它主要使用一个名为ICE ( Interactive Connectivity Establishment ) 的框架来进行穿透内网，它內部整合了 STUN 与 TURN 协议。</p></blockquote><ul><li><p>STUN ( Session Traversal Utilities for NAT ) 中文为 NAT 对谈穿透程序，它的最主要用处就是帮助在 NAT 內的用戶找到可以连到它的位置。</p></li><li><p>TURN ( Traversal Using Relay NAT )，它也是一种穿透 NAT 的协议，不過它是使用中继的方式来进行，通常都是 STUN 的候选位置都无法连接時，才会使用它。</p></li></ul><blockquote><p>由于我们只需要获取本方的内网ip，其实我们不需要连接到STUN 或者 TURN 服务</p></blockquote><h4 id="流程如下"><a href="#流程如下" class="headerlink" title="流程如下"></a>流程如下</h4><p>1.实例化 peerconnection。</p><p>2.设置监听事件 onicecandidate。</p><p>3.然后创建呼叫createOffer将这个连接实例保存为本地sdp信息，setLocalDescription最后通过服务器向对方发送offer,内容包括己方的sdp信息。</p><p>4.对方 接收到offer发送answer （本实验不需要， 没有实现）。</p><p>5.触发ice事件， 调用之前设置的监听回调函数 向对方发送ice候选者。</p><p>6.获取回调函数中关于本方 ice候选者的address 信息，即我们需要获取输数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">// javascript</span><br><span class="line">// 创建一个peer Connection</span><br><span class="line">  </span><br><span class="line">// 正常情况下需要传入一个stun的service配置</span><br><span class="line">const iceServers = [];</span><br><span class="line">iceServers.push(JSON.parse(&apos;&#123;&quot;urls&quot;:[&quot;stun:stun.l.google.com:19302&quot;],&quot;username&quot;:&quot;&quot;,&quot;credential&quot;:&quot;&quot;&#125;&apos;));</span><br><span class="line">pc = new RTCPeerConnection(iceServers);</span><br><span class="line">  </span><br><span class="line">// 由于我们其实不需要真的去发送/获取候选信息 所以也可以不传</span><br><span class="line">pc = new RTCPeerConnection(null);</span><br><span class="line">   </span><br><span class="line">// 监听ice事件向对方发送ice候选者，其实也不用发送，只要把有用的本方信息保存即可</span><br><span class="line">pc.onicecandidate = function (event) &#123;</span><br><span class="line">    if (event.candidate) &#123;</span><br><span class="line">        var c = parseCandidate(event.candidate.candidate);</span><br><span class="line">        var ip_regex = /([0-9]&#123;1,3&#125;(\.[0-9]&#123;1,3&#125;)&#123;3&#125;)/;</span><br><span class="line">        var ip = ip_regex.exec(c.address);</span><br><span class="line">        var ip_addr = &apos;unkonw&apos;;</span><br><span class="line">        if (ip &amp;&amp; ip[1]) &#123;</span><br><span class="line">            ip_addr = ip[1];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            console.log(&quot;not support&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        if (ip_dups[ip_addr] === undefined) &#123;</span><br><span class="line">            console.log(ip_addr);</span><br><span class="line">        &#125;</span><br><span class="line">        ip_dups[ip_addr] = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">// createOffer将这个连接实例保存为本地sdp信息 setLocalDescription最后通过服务器向对方发送offer,内容包括己方的sdp信息</span><br><span class="line">// desc.sdp 可以通过这个查看sdp信息</span><br><span class="line">// offerOptions</span><br><span class="line">pc.createOffer(offerOptions).then(</span><br><span class="line">    function (desc) &#123;</span><br><span class="line">        pc.setLocalDescription(desc);</span><br><span class="line">    &#125;,</span><br><span class="line">      </span><br><span class="line">    function () &#123;</span><br><span class="line">        //log error</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      WebRTC, 获取内网ip。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>aws以及shadowsocket</title>
    <link href="http://www.zhengwenkai.com/2017/11/21/aws_ss/"/>
    <id>http://www.zhengwenkai.com/2017/11/21/aws_ss/</id>
    <published>2017-11-21T10:01:40.000Z</published>
    <updated>2017-11-21T10:05:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>一直嫌麻烦都是直接买的vpn，最近一直使用的vpn无法使用了，又不想装那种vpn客户端，有人推荐的蓝灯，下载一看觉得太贵了。既然都没有满意的就买一个vps自己搞吧。以前申请过aws，就拿它先练练手了</p><ul><li><p>aws</p><p>  1.直接用以前的账号登陆。如果没有的话可以注册一下</p><p>  2.信用卡是之前就绑定好了，没有的话不知道有没有办法绕过。看过一些文章说是可以用虚拟卡，具体操作可以百度</p><p>  3.进入控制台，选择免费的ec2。目前应该是15G以内的流量免费。是否付费，可以自行选择。不想付费，千万别用超了</p><p>  4.我建了一个ubuntu，安装了npm。</p></li><li><p>shadowsockets 部署</p><p>  1.npm install -g shadowsocks 安装<br>  2.在 /usr/local/lib/node_modules/shadowsocks 目录下可以找到配置文件,我简单配置了一下</p><pre>{  "server":"0.0.0.0",  "server_port":8389,  "local_address":"127.0.0.1",  "local_port":1080,  "password":"myladder123",  "timeout":600,  "method":"aes-256-cfb"}</pre><p>  3.ssserver 启动</p></li><li><p>客户端</p></li></ul><p>找到任何支持shadowsock 的客户端<br>按上面的配置 填入服务器的配置信息链接。不出问题应该就可了</p><blockquote><p>注意的是在aws实例的安全配置需要 配置的入站的端口和ip<br>端口就是你开放给客户端的端口，ip如果自用 可以指定ip。也可以选任意ip</p></blockquote>]]></content>
    
    <summary type="html">
    
      aws使用, shadowsocket安装启动, 客户端配置
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>手动安装zsh</title>
    <link href="http://www.zhengwenkai.com/2017/06/01/zsh_install/"/>
    <id>http://www.zhengwenkai.com/2017/06/01/zsh_install/</id>
    <published>2017-06-01T10:30:38.000Z</published>
    <updated>2017-06-01T10:30:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>接手一个老旧的项目，只能在开发机上开发。果断给自己安装zsh, 就算是只为了git插件也值得安装。(无root权限)</p><ul><li>下载</li></ul><p><code>wget http://sourceforge.net/projects/zsh/files/zsh/5.0.7/zsh-5.0.7.tar.gz</code></p><ul><li>安装</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ~/tmp/zsh-5.0.7</span><br><span class="line">./configure --prefix=$HOME</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><ul><li>安装 oh my zsh</li></ul><p>自动安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O - | sh</span><br></pre></td></tr></table></figure><blockquote><p>我试了自动安装会提示 Zsh is not installed! Please install zsh first!。看了一下安装的sh文件，会搜索 /etc/shells 文件 <code>$(grep /zsh$ /etc/shells | wc -l)</code></p></blockquote><p>手动安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</span><br><span class="line">cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</span><br></pre></td></tr></table></figure><blockquote><p>最后就是设置成默认的shell。chsh这个命令是不能用了，因为没有root权限，所以只能在 .bash_profile 里面做手脚了。在 .bash_profile里面添加如下内容：<br><code>exec $HOME/bin/zsh -l</code><br>好了现在ssh连接到服务器上就变了zsh了。</p></blockquote><ul><li>安装autojump</li></ul><p>下载</p><p><code>git clone git://github.com/joelthelion/autojump.git</code></p><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">进入autojump的目录 执行安装的py脚本</span><br><span class="line">./install.py</span><br></pre></td></tr></table></figure><p>安装完后，按照提示 最后把以下代码加入.zshrc：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[ -s ~/.autojump/etc/profile.d/autojump.sh ]] &amp;&amp; . ~/.autojump/etc/profile.d/autojump.sh</span><br></pre></td></tr></table></figure></p><p>cd 过一次的目录 下次都可以直接跳转<br>重新打开一个shell窗口，尝试一下吧。</p>]]></content>
    
    <summary type="html">
    
      zsh安装，zsh插件
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用hexo生成blog</title>
    <link href="http://www.zhengwenkai.com/2017/05/27/create_blog/"/>
    <id>http://www.zhengwenkai.com/2017/05/27/create_blog/</id>
    <published>2017-05-27T06:44:50.000Z</published>
    <updated>2017-05-27T07:18:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>  一直在想这个blog该写一些什么。导致半年过去了什么也没写，发现连hexo都忘了怎么用。于是决定就写hexo用法的作为这个blog的第一篇文章好了。</p><ul><li><p>安装 </p><p>当然首先你得有nodejs和npm。</p></li></ul><ol><li><p>新建一个目录。什么myblog、newblog都行。</p></li><li><p>执行如下命令安装Hexo<br><code>sudo npm install -g hexo</code></p></li><li><p>执行init命令初始化hexo,命令<br><code>hexo init</code></p></li><li><p>生成静态页面<br><code>hexo generate</code> 或者 <code>hexo g</code></p></li><li><p>启动本地服务，进行文章预览调试.<code>hexo server</code><br>浏览器输入<a href="http://localhost:4000。" target="_blank" rel="noopener">http://localhost:4000。</a> port 4000 是默认的</p></li></ol><ul><li><p>发布</p><p> 我的blog托管在github上，所以在blog目录的_config.yaml文件配置上github的相关信息。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/xxxxx/xxxx.github.io.git</span><br><span class="line">  branch: master</span><br><span class="line">  message:</span><br></pre></td></tr></table></figure><p>执行发布<br><code>hexo deploy</code></p>]]></content>
    
    <summary type="html">
    
      hexo安装，使用，文章发布
    
    </summary>
    
    
  </entry>
  
</feed>
