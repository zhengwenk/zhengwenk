<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>啊凯说</title>
  
  <subtitle>一个越写越多(希望)的技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.zhengwenkai.com/"/>
  <updated>2019-09-12T08:07:45.339Z</updated>
  <id>https://www.zhengwenkai.com/</id>
  
  <author>
    <name>口阿岂几(https://www.zhengwenkai.com)</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Golang Http包</title>
    <link href="https://www.zhengwenkai.com/tech-notes/golang-http-1568202850.html"/>
    <id>https://www.zhengwenkai.com/tech-notes/golang-http-1568202850.html</id>
    <published>2019-09-11T03:54:10.000Z</published>
    <updated>2019-09-12T08:07:45.339Z</updated>
    
    <content type="html"><![CDATA[<h1 id="http包"><a href="#http包" class="headerlink" title="http包"></a>http包</h1><p>Package http</p><p>使用</p><pre><code>import &quot;net/http&quot;</code></pre><p><em>Package http provides HTTP client and server implementations.</em></p><p><strong><em>http包提供http客户端和服务端的实现</em></strong></p><p><em>ListenAndServe starts an HTTP server with a given address and handler. </em></p><p><strong><em>ListenAndServe方法使用一个地址和处理函数启动一个http服务</em></strong></p><p><em>The handler is usually nil, which means to use DefaultServeMux. </em></p><p><strong><em>handler通常是nil，这意味者使用DefaultServeMux</em></strong></p><p><em>Handle and HandleFunc add handlers to DefaultServeMux:</em></p><p><strong><em>Handle 和 HandleFunc 方法可以添加handlers到DefaultServeMux</em></strong></p><h3 id="Handle-和-HandleFunc-的使用"><a href="#Handle-和-HandleFunc-的使用" class="headerlink" title="Handle 和 HandleFunc 的使用"></a>Handle 和 HandleFunc 的使用</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Handle 和 HandleFunc 的使用</span></span><br><span class="line">http.Handle(<span class="string">"/foo"</span>, fooHandler)</span><br><span class="line">    </span><br><span class="line">http.HandleFunc(<span class="string">"/bar"</span>, func(w http<span class="selector-class">.ResponseWriter</span>, r *http.Request) &#123;</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"Hello, %q"</span>, <span class="selector-tag">html</span>.EscapeString(r<span class="selector-class">.URL</span><span class="selector-class">.Path</span>))</span><br><span class="line">&#125;)</span><br><span class="line">    </span><br><span class="line">log.Fatal(http.ListenAndServe(<span class="string">":8080"</span>, nil))</span><br></pre></td></tr></table></figure><h3 id="ListenAndServe-函数"><a href="#ListenAndServe-函数" class="headerlink" title="ListenAndServe 函数"></a>ListenAndServe 函数</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">package http</span><br><span class="line">  </span><br><span class="line">  // server.go </span><br><span class="line">  </span><br><span class="line">  // ListenAndServe listens on the TCP network address addr and then calls</span><br><span class="line">  // ListenAndServe方法 监听TCP网络地址 addr(传入参数) 然后调用</span><br><span class="line">  // Serve <span class="keyword">with</span> <span class="keyword">handler</span> <span class="keyword">to</span> handle requests <span class="keyword">on</span> incoming connections.</span><br><span class="line">  // Serve绑定的<span class="keyword">handler</span>处理连接上的请求。</span><br><span class="line">  // Accepted connections <span class="keyword">are</span> configured <span class="keyword">to</span> <span class="keyword">enable</span> TCP <span class="keyword">keep</span>-alives.</span><br><span class="line">  // 接到的连接被配置为启用 TCP <span class="keyword">keep</span>-alives</span><br><span class="line">  // The <span class="keyword">handler</span> <span class="keyword">is</span> typically nil, <span class="keyword">in</span> which <span class="keyword">case</span> the DefaultServeMux <span class="keyword">is</span> used.</span><br><span class="line">  // 处理程序通常为nil，在这种情况下使用DefaultServeMux</span><br><span class="line">  // ListenAndServe <span class="keyword">always</span> <span class="keyword">returns</span> a non-nil error.</span><br><span class="line">  func ListenAndServe(addr <span class="keyword">string</span>, <span class="keyword">handler</span> <span class="keyword">Handler</span>) <span class="keyword">error</span> &#123;</span><br><span class="line">  <span class="keyword">server</span> := &amp;<span class="keyword">Server</span>&#123;Addr: addr, <span class="keyword">Handler</span>: <span class="keyword">handler</span>&#125;</span><br><span class="line">  <span class="keyword">return</span> server.ListenAndServe()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // server.ListenAndServe</span><br><span class="line">  // ListenAndServe listens <span class="keyword">on</span> the TCP network address srv.Addr <span class="keyword">and</span> <span class="keyword">then</span></span><br><span class="line">  // calls Serve <span class="keyword">to</span> handle requests <span class="keyword">on</span> incoming connections.</span><br><span class="line">  // Accepted connections <span class="keyword">are</span> configured <span class="keyword">to</span> <span class="keyword">enable</span> TCP <span class="keyword">keep</span>-alives.</span><br><span class="line">  //</span><br><span class="line">  // <span class="keyword">If</span> srv.Addr <span class="keyword">is</span> blank, <span class="string">":http"</span> <span class="keyword">is</span> used.</span><br><span class="line">  // 如果srv.Addr为空，默认使用 <span class="string">":http"</span></span><br><span class="line">  //</span><br><span class="line">  // ListenAndServe <span class="keyword">always</span> <span class="keyword">returns</span> a non-nil error. <span class="keyword">After</span> <span class="keyword">Shutdown</span> <span class="keyword">or</span> <span class="keyword">Close</span>,</span><br><span class="line">  // ListenAndServe 方法始终返回一个非nil的<span class="keyword">error</span>，<span class="keyword">Shutdown</span> <span class="keyword">or</span> <span class="keyword">Close</span> 后</span><br><span class="line">  // the returned <span class="keyword">error</span> <span class="keyword">is</span> ErrServerClosed.</span><br><span class="line">  // 被返回的<span class="keyword">error</span>是 ErrServerClosed</span><br><span class="line">  func (srv *<span class="keyword">Server</span>) ListenAndServe() <span class="keyword">error</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> srv.shuttingDown() &#123;</span><br><span class="line">  <span class="keyword">return</span> ErrServerClosed</span><br><span class="line">  &#125;</span><br><span class="line">  addr := srv.Addr</span><br><span class="line">  <span class="keyword">if</span> addr == <span class="string">""</span> &#123;</span><br><span class="line">  addr = <span class="string">":http"</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 监听tcp</span><br><span class="line">  <span class="keyword">ln</span>, err := net.Listen(<span class="string">"tcp"</span>, addr)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">    // 调用 Serve处理请求</span><br><span class="line">  <span class="keyword">return</span> srv.Serve(tcpKeepAliveListener&#123;ln.(*net.TCPListener)&#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="Server-Serve"><a href="#Server-Serve" class="headerlink" title="Server.Serve"></a>Server.Serve</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// Serve accepts incoming connections on the Listener l, creating a</span></span><br><span class="line">  <span class="comment">// new service goroutine for each. The service goroutines read requests and</span></span><br><span class="line">  <span class="comment">// then call srv.Handler to reply to them.</span></span><br><span class="line">  <span class="comment">// Serve方法接受 Listener l (监听者)传入的连接，为每个连接创建一个新的service goroutine</span></span><br><span class="line">  <span class="comment">// service goroutine读取请求并调用srv.Handler方法处理请求并响应</span></span><br><span class="line">  <span class="comment">// HTTP/2 support is only enabled if the Listener returns *tls.Conn</span></span><br><span class="line">  <span class="comment">// connections and they were configured with "h2" in the TLS</span></span><br><span class="line">  <span class="comment">// Config.NextProtos.</span></span><br><span class="line">  <span class="comment">// 只有Listener returns *tls.Conn connections 并且他们 在TLS</span></span><br><span class="line">  <span class="comment">// Config.NextProtos 被配置为 "h2"</span></span><br><span class="line">  <span class="comment">// Serve always returns a non-nil error and closes l.</span></span><br><span class="line">  <span class="comment">// After Shutdown or Close, the returned error is ErrServerClosed.</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">Serve</span><span class="params">(l net.Listener)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> fn := testHookServerServe; fn != <span class="literal">nil</span> &#123;</span><br><span class="line">  fn(srv, l) <span class="comment">// call hook with unwrapped listener</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//onceCloseListener wraps a net.Listener, protecting it from multiple Close calls.</span></span><br><span class="line">     <span class="comment">//onceCloseListener 是对net.Listener 封装，用以防止多次close的调用.</span></span><br><span class="line">  l = &amp;onceCloseListener&#123;Listener: l&#125;</span><br><span class="line">  <span class="keyword">defer</span> l.Close()</span><br><span class="line">  </span><br><span class="line">     <span class="comment">// 启动http2 (具体代码暂不分析)</span></span><br><span class="line">  <span class="keyword">if</span> err := srv.setupHTTP2_Serve(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> !srv.trackListener(&amp;l, <span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> ErrServerClosed</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> srv.trackListener(&amp;l, <span class="literal">false</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> tempDelay time.Duration     </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 一个是Background，主要用于main函数、初始化以及测试代码中，</span></span><br><span class="line">    <span class="comment">// 作为Context这个树结构的最顶层的Context，也就是根Context，它不能被取消。</span></span><br><span class="line">  baseCtx := context.Background() <span class="comment">// base is always background, per Issue 16220</span></span><br><span class="line">  ctx := context.WithValue(baseCtx, ServerContextKey, srv)</span><br><span class="line">    <span class="comment">// 核心循环</span></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="comment">// Accept waits for and returns the next connection to the listener.</span></span><br><span class="line">      <span class="comment">// Accept() (Conn, error)</span></span><br><span class="line">  rw, e := l.Accept()</span><br><span class="line">  <span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="comment">// Go 语言中提供了 select 关键字，可以同时响应多个通道的操作。</span></span><br><span class="line">          <span class="comment">// select 的每个 case 都会对应一个通道的收发过程。</span></span><br><span class="line">  <span class="comment">//当收发完成时，就会触发 case 中响应的语句。</span></span><br><span class="line">      <span class="comment">//多个操作在每次 select 中挑选一个进行响应。</span></span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> &lt;-srv.getDoneChan():</span><br><span class="line">  <span class="keyword">return</span> ErrServerClosed</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">  &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">  <span class="keyword">if</span> ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() &#123;</span><br><span class="line">  <span class="keyword">if</span> tempDelay == <span class="number">0</span> &#123;</span><br><span class="line">  tempDelay = <span class="number">5</span> * time.Millisecond</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  tempDelay *= <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> max := <span class="number">1</span> * time.Second; tempDelay &gt; max &#123;</span><br><span class="line">  tempDelay = max</span><br><span class="line">  &#125;</span><br><span class="line">  srv.logf(<span class="string">"http: Accept error: %v; retrying in %v"</span>, e, tempDelay)</span><br><span class="line">  time.Sleep(tempDelay)</span><br><span class="line">  <span class="keyword">continue</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> e</span><br><span class="line">  &#125;</span><br><span class="line">  tempDelay = <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">      <span class="comment">// Create new connection from rwc.</span></span><br><span class="line">  c := srv.newConn(rw)</span><br><span class="line">  c.setState(c.rwc, StateNew) <span class="comment">// before Serve can return</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// Go 程序中使用 go 关键字为一个函数创建一个 goroutine。</span></span><br><span class="line">      <span class="comment">//  一个函数可以被创建多个 goroutine，一个 goroutine 必定对应一个函数。</span></span><br><span class="line">      <span class="comment">// Serve a new connection</span></span><br><span class="line">  <span class="keyword">go</span> c.serve(ctx)</span><br><span class="line">  <span class="comment">// Go 为了实现高并发和高性能，使用了 goroutines 来处理 Conn 的读写事件，</span></span><br><span class="line">  <span class="comment">// 这样每个请求都能保持独立，相互不会阻塞，可以高效的响应网络事件。</span></span><br><span class="line">  <span class="comment">// 这是 Go 高效的保证。</span></span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(c *conn)</span> <span class="title">serve</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// serverHandler delegates to either the server's Handler or</span></span><br><span class="line">  <span class="comment">// DefaultServeMux and also handles "OPTIONS *" requests.</span></span><br><span class="line">  serverHandler&#123;c.server&#125;.ServeHTTP(w, w.req)</span><br><span class="line">  </span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">type</span> ServeMux <span class="keyword">struct</span> &#123;</span><br><span class="line">  mu    sync.RWMutex</span><br><span class="line">  m     <span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry</span><br><span class="line">  es    []muxEntry <span class="comment">// slice of entries sorted from longest to shortest.</span></span><br><span class="line">  hosts <span class="keyword">bool</span>       <span class="comment">// whether any patterns contain hostnames</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// DefaultServeMux is the default ServeMux used by Serve.</span></span><br><span class="line">   <span class="keyword">var</span> DefaultServeMux = &amp;defaultServeMux</span><br><span class="line">   <span class="keyword">var</span> defaultServeMux ServeMux</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(sh serverHandler)</span> <span class="title">ServeHTTP</span><span class="params">(rw ResponseWriter, req *Request)</span></span> &#123;</span><br><span class="line">  handler := sh.srv.Handler</span><br><span class="line">  <span class="comment">// 这里handler是通过 http.ListenAndServe 方法传入的 nil, 所以会被赋默认值</span></span><br><span class="line">  <span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">  handler = DefaultServeMux</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2种特殊请求 单独处理</span></span><br><span class="line">  <span class="keyword">if</span> req.RequestURI == <span class="string">"*"</span> &amp;&amp; req.Method == <span class="string">"OPTIONS"</span> &#123;</span><br><span class="line">  handler = globalOptionsHandler&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  handler.ServeHTTP(rw, req)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> r.RequestURI == <span class="string">"*"</span> &#123;</span><br><span class="line">  <span class="comment">// 判断http的版本是否至少是1.1</span></span><br><span class="line">  <span class="keyword">if</span> r.ProtoAtLeast(<span class="number">1</span>, <span class="number">1</span>) &#123;</span><br><span class="line">  w.Header().Set(<span class="string">"Connection"</span>, <span class="string">"close"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  w.WriteHeader(StatusBadRequest)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">  h, _ := mux.Handler(r)</span><br><span class="line">  h.ServeHTTP(w, r)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">Handler</span><span class="params">(r *Request)</span> <span class="params">(h Handler, pattern <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// CONNECT requests are not canonicalized.</span></span><br><span class="line">    <span class="comment">// CONNECT 请求不是一个标准请求，</span></span><br><span class="line">  <span class="keyword">if</span> r.Method == <span class="string">"CONNECT"</span> &#123;</span><br><span class="line">  <span class="comment">// If r.URL.Path is /tree and its handler is not registered,</span></span><br><span class="line">      <span class="comment">// 假设 r.URL.Path is == "/tree" 并且 handler 没有被注册</span></span><br><span class="line">  <span class="comment">// the /tree -&gt; /tree/ redirect applies to CONNECT requests</span></span><br><span class="line">      <span class="comment">// /tree -&gt; /tree/ 的重定向会被用于 CONNECT 的请求</span></span><br><span class="line">  <span class="comment">// but the path canonicalization does not.</span></span><br><span class="line">  <span class="keyword">if</span> u, ok := mux.redirectToPathSlash(r.URL.Host, r.URL.Path, r.URL); ok &#123;</span><br><span class="line">  <span class="comment">// 301 重定向</span></span><br><span class="line">  <span class="keyword">return</span> RedirectHandler(u.String(), StatusMovedPermanently), u.Path</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> mux.handler(r.Host, r.URL.Path)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// All other requests have any port stripped and path cleaned</span></span><br><span class="line">  <span class="comment">// before passing to mux.handler.</span></span><br><span class="line">  <span class="comment">// 在通过mux.handler之前 所有其他的请求 r.Host含有port的部分会被清除</span></span><br><span class="line">    <span class="comment">// path会被清洗</span></span><br><span class="line">  host := stripHostPort(r.Host)</span><br><span class="line">  path := cleanPath(r.URL.Path)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// If the given path is /tree and its handler is not registered,</span></span><br><span class="line">  <span class="comment">// redirect for /tree/.</span></span><br><span class="line">  <span class="keyword">if</span> u, ok := mux.redirectToPathSlash(host, path, r.URL); ok &#123;</span><br><span class="line">  <span class="keyword">return</span> RedirectHandler(u.String(), StatusMovedPermanently), u.Path</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> path != r.URL.Path &#123;</span><br><span class="line">  _, pattern = mux.handler(host, path)</span><br><span class="line">  url := *r.URL</span><br><span class="line">  url.Path = path</span><br><span class="line">  <span class="keyword">return</span> RedirectHandler(url.String(), StatusMovedPermanently), pattern</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> mux.handler(host, r.URL.Path)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// redirectToPathSlash determines if the given path needs appending "/" to it.</span></span><br><span class="line">  <span class="comment">// 该方法确定被给的path是否需要追加 "/"</span></span><br><span class="line">  <span class="comment">// This occurs when a handler for path + "/" was already registered, but</span></span><br><span class="line">  <span class="comment">// not for path itself. If the path needs appending to, it creates a new</span></span><br><span class="line">  <span class="comment">// URL, setting the path to u.Path + "/" and returning true to indicate so.</span></span><br><span class="line">  <span class="comment">// 当一个 处理 path + "/" handler 被注册, 而不是 path 本身。如果path需要被追加，</span></span><br><span class="line">  <span class="comment">// 则会创建一个新的url，设置path= u.Path + "/", 并返回true来表示</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">redirectToPathSlash</span><span class="params">(host, path <span class="keyword">string</span>, u *url.URL)</span> <span class="params">(*url.URL, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">  mux.mu.RLock()</span><br><span class="line">  shouldRedirect := mux.shouldRedirectRLocked(host, path)</span><br><span class="line">  mux.mu.RUnlock()</span><br><span class="line">  <span class="keyword">if</span> !shouldRedirect &#123;</span><br><span class="line">  <span class="keyword">return</span> u, <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  path = path + <span class="string">"/"</span></span><br><span class="line">  u = &amp;url.URL&#123;Path: path, RawQuery: u.RawQuery&#125;</span><br><span class="line">  <span class="keyword">return</span> u, <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">shouldRedirectRLocked</span><span class="params">(host, path <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  p := []<span class="keyword">string</span>&#123;path, host + path&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> _, c := <span class="keyword">range</span> p &#123;</span><br><span class="line">  <span class="comment">// 判断path 是否被定义在mux.m中，存在返回true </span></span><br><span class="line">  <span class="keyword">if</span> _, exist := mux.m[c]; exist &#123;</span><br><span class="line">  <span class="comment">// 不需要改写</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  n := <span class="built_in">len</span>(path)</span><br><span class="line">  <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> _, c := <span class="keyword">range</span> p &#123;</span><br><span class="line">  <span class="keyword">if</span> _, exist := mux.m[c+<span class="string">"/"</span>]; exist &#123;</span><br><span class="line">  <span class="keyword">return</span> path[n<span class="number">-1</span>] != <span class="string">'/'</span></span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// handler is the main implementation of Handler.</span></span><br><span class="line">  <span class="comment">// handler是Handler的主要实现</span></span><br><span class="line">  <span class="comment">// The path is known to be in canonical form, except for CONNECT methods.</span></span><br><span class="line">  <span class="comment">// 除了CONNECT方法之外 path已经是规范形式的。</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">handler</span><span class="params">(host, path <span class="keyword">string</span>)</span> <span class="params">(h Handler, pattern <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 由于请求涉及到并发处理，因此这里需要一个锁机制</span></span><br><span class="line">  mux.mu.RLock()</span><br><span class="line">  <span class="keyword">defer</span> mux.mu.RUnlock()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Host-specific pattern takes precedence over generic ones</span></span><br><span class="line">  <span class="comment">// 特殊的host 匹配会优先覆盖一般的。</span></span><br><span class="line">  <span class="comment">// 主要是处理多host服务的请求</span></span><br><span class="line">  <span class="keyword">if</span> mux.hosts &#123;</span><br><span class="line">  h, pattern = mux.match(host + path)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">  h, pattern = mux.match(path)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">  h, pattern = NotFoundHandler(), <span class="string">""</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Find a handler on a handler map given a path string.</span></span><br><span class="line">  <span class="comment">// Most-specific (longest) pattern wins.</span></span><br><span class="line">  <span class="comment">// 匹配path 对应的handler</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">match</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="params">(h Handler, pattern <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">// Check for exact match first.</span></span><br><span class="line">    <span class="comment">// 精确匹配</span></span><br><span class="line">  v, ok := mux.m[path]</span><br><span class="line">  <span class="keyword">if</span> ok &#123;</span><br><span class="line">  <span class="keyword">return</span> v.h, v.pattern</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Check for longest valid match.  mux.es contains all patterns</span></span><br><span class="line">  <span class="comment">// that end in / sorted from longest to shortest.</span></span><br><span class="line">  <span class="comment">// 最长有效匹配， mux.es 包含所有 以 "/" 结尾的匹配 从长到短</span></span><br><span class="line">  <span class="keyword">for</span> _, e := <span class="keyword">range</span> mux.es &#123;</span><br><span class="line">  <span class="keyword">if</span> strings.HasPrefix(path, e.pattern) &#123;</span><br><span class="line">  <span class="keyword">return</span> e.h, e.pattern</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span>, <span class="string">""</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="net-Listen"><a href="#net-Listen" class="headerlink" title="net.Listen"></a>net.Listen</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Listen announces on the local network address.</span></span><br><span class="line"><span class="comment">// 监听本地网络地址的通知</span></span><br><span class="line"><span class="comment">// The network must be "tcp", "tcp4", "tcp6", "unix" or "unixpacket".</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// For TCP networks, if the host in the address parameter is empty or</span></span><br><span class="line"><span class="comment">// a literal unspecified IP address, Listen listens on all available</span></span><br><span class="line"><span class="comment">// unicast and anycast IP addresses of the local system.</span></span><br><span class="line"><span class="comment">// 对于tcp网络 如果address参数中的主机为空或者是一个子面未指定的ip地址，</span></span><br><span class="line"><span class="comment">// Listen方法监听所有可用的本地系统的单播和任波的ip地址</span></span><br><span class="line"><span class="comment">// To only use IPv4, use network "tcp4".</span></span><br><span class="line"><span class="comment">// 如果仅使用IPv4 network 可以使用 "tcp4"。</span></span><br><span class="line"><span class="comment">// The address can use a host name, but this is not recommended,</span></span><br><span class="line"><span class="comment">// address 可以使用host name，但是不推荐</span></span><br><span class="line"><span class="comment">// because it will create a listener for at most one of the host's IP</span></span><br><span class="line"><span class="comment">// addresses.</span></span><br><span class="line"><span class="comment">// 因为 这只会为最多一个主机的ip地址创建监听</span></span><br><span class="line"><span class="comment">// If the port in the address parameter is empty or "0", as in</span></span><br><span class="line"><span class="comment">// "127.0.0.1:" or "[::1]:0", a port number is automatically chosen.</span></span><br><span class="line"><span class="comment">// 如果address 参数中的port是空或者 "0", 例如 "127.0.0.1:" or "[::1]:0"</span></span><br><span class="line"><span class="comment">// 会自动选择一个端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The Addr method of Listener can be used to discover the chosen</span></span><br><span class="line"><span class="comment">// port.</span></span><br><span class="line"><span class="comment">// Listener的Addr方法可以用于发现所选的端口</span></span><br><span class="line"><span class="comment">// See func Dial for a description of the network and address</span></span><br><span class="line"><span class="comment">// parameters.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Listen</span><span class="params">(network, address <span class="keyword">string</span>)</span> <span class="params">(Listener, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> lc ListenConfig</span><br><span class="line"><span class="keyword">return</span> lc.Listen(context.Background(), network, address)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Context背景-和-适用场景"><a href="#Context背景-和-适用场景" class="headerlink" title="Context背景 和 适用场景"></a>Context背景 和 适用场景</h3><p>golang在1.6.2的时候还没有自己的context，在1.7的版本中就把</p><p>golang.org/x/net/context包被加入到了官方的库中。</p><p>golang 的 Context包，是专门用来简化对于处理单个请求的多个goroutine之间与请求域的数据、取消信号、截止时间等相关操作，这些操作可能涉及多个 API 调用。</p><p>比如有一个网络请求Request，每个Request都需要开启一个goroutine做一些事情，这些goroutine又可能会开启其他的goroutine。这样的话， 我们就可以通过Context，来跟踪这些goroutine，并且通过Context来控制他们的目的，这就是Go语言为我们提供的Context，中文可以称之为“上下文”。</p><p>另外一个实际例子是，在Go服务器程序中，每个请求都会有一个goroutine去处理。然而，处理程序往往还需要创建额外的goroutine去访问后端资源，比如数据库、RPC服务等。由于这些goroutine都是在处理同一个请求，所以它们往往需要访问一些共享的资源，比如用户身份信息、认证token、请求截止时间等。而且如果请求超时或者被取消后，所有的goroutine都应该马上退出并且释放相关的资源。这种情况也需要用Context来为我们取消掉所有goroutine</p>]]></content>
    
    <summary type="html">
    
      golang http包源码翻译
    
    </summary>
    
      <category term="技术" scheme="https://www.zhengwenkai.com/categories/tech-notes/"/>
    
    
      <category term="golang" scheme="https://www.zhengwenkai.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang Encoding/json Marshal方法</title>
    <link href="https://www.zhengwenkai.com/tech-notes/golang-encodingjson-Marshal-1568202670.html"/>
    <id>https://www.zhengwenkai.com/tech-notes/golang-encodingjson-Marshal-1568202670.html</id>
    <published>2019-09-11T03:51:10.000Z</published>
    <updated>2019-09-12T08:14:39.837Z</updated>
    
    <content type="html"><![CDATA[<h3 id="func-Marshal"><a href="#func-Marshal" class="headerlink" title="func Marshal"></a><strong>func Marshal</strong></h3><pre><code>func Marshal(v interface{}) ([]byte, error)</code></pre><p><strong>Marshal returns the JSON encoding of v.</strong></p><p>Marshal traverses the value v recursively.<code>（Marshal 递归的遍历v值）</code></p><p>If an encountered value implements the Marshaler interface and is not a nil pointer <code>（如果遇到一个实现Marshaler interface 并且不是一个空指针的值）</code>Marshal calls its MarshalJSON method to produce JSON.</p><p>If no MarshalJSON method is present but the value implements encoding.TextMarshaler instead,<code>(如果不存在MarshalJSON 方法,但是value实现encoding.TextMarshaler)</code> Marshal calls its MarshalText method and encodes the result as a JSON string. <code>(则Marshal调用其MarshalText方法并将结果编码为JSON字符串)</code></p><p>The nil pointer exception is not strictly necessary but mimics a similar, necessary exception in the behavior of UnmarshalJSON. <code>(空指针异常不是绝对必要的，但是在UnmarshalJSON方法的行为中模仿了类似的必要异常)</code></p><p>Otherwise, Marshal uses the following type-dependent default encodings:</p><p><code>另外Marshal 使用如下类型相关的默认编码</code></p><p>Boolean values encode as JSON booleans.</p><p>Floating point, integer, and Number values encode as JSON numbers.</p><p>String values encode as JSON strings coerced to valid UTF-8, </p><p><code>字符串值编码为强制为有效UTF-8的JSON字符串</code></p><p>replacing invalid bytes with the Unicode replacement rune. </p><p><code>用Unicode replacement rune替换无效的字节</code></p><p>The angle brackets “&lt;” and “&gt;” are escaped to “\u003c” and “\u003e” to keep some browsers from misinterpreting JSON output as HTML. </p><p><code>尖括号“&lt;”和“&gt;”被转义为“\ u003c”和“\ u003e” 以防止某些浏览器将JSON输出误解为HTML</code></p><p>Ampersand “&amp;” is also escaped to “\u0026” for the same reason.</p><p><code>同样的Ampersand &quot;&amp;&quot; 也被转义为&quot;\u0026&quot;</code></p><p> This escaping can be disabled using an Encoder that had SetEscapeHTML(false) called on it.</p><p><code>可以使用调用了SetEscapeHTML（false）的编码器禁用此转义</code></p><p>Array and slice values encode as JSON arrays, except that []byte encodes as a base64-encoded string, and a nil slice encodes as the null JSON value.</p><p><code>数组和切片值编码为JSON数组，但[]字节编码为base64编码的字符串，而nil切片编码为空JSON对象。</code></p><p>Struct values encode as JSON objects. Each exported struct field becomes a member of the object, using the field name as the object key, unless the field is omitted for one of the reasons given below.</p><p><code>结构体的值编码为JSON对象。每个导出的struct字段都成为对象的成员，使用字段名作为对象键,除非出于下面给出的原因，省略该字段</code></p><p>The encoding of each struct field can be customized by the format string stored under the “json” key in the struct field’s tag. </p><p><code>每个结构字段的编码可以通过存储在struct字段标记中的“json”键下的格式字符串来定制</code></p><p>The format string gives the name of the field, possibly followed by a comma-separated list of options.</p><p><code>格式字符串给出了字段的名称，可能后跟逗号分隔的选项列表。</code></p><p>The name may be empty in order to specify options without overriding the default field name.</p><p><code>名称可以为空，以便指定选项而不覆盖默认字段名称。</code></p><p>The “omitempty” option specifies that the field should be omitted from the encoding if the field has an empty value, defined as false, 0, a nil pointer, a nil interface value, and any empty array, slice, map, or string.</p><p><code>“omitempty”选项指定如果字段是空值(被定义为false, 0 , nil指针，nil接口以及任何空数组、切片、map、字符串等)，则应从编码中省略该字段</code></p><p>As a special case, if the field tag is “-“, the field is always omitted. Note that a field with name “-“ can still be generated using the tag “-,”.</p><p>Examples of struct field tags and their meanings:</p><pre><code>package mainimport (    &quot;encoding/json&quot;    &quot;fmt&quot;    &quot;os&quot;)func main() {    type ColorGroup struct {        ID     int        Name   string        Colors []string    }    group := ColorGroup{        ID:     1,        Name:   &quot;Reds&quot;,        Colors: []string{&quot;Crimson&quot;, &quot;Red&quot;, &quot;Ruby&quot;, &quot;Maroon&quot;},    }    b, err := json.Marshal(group)    if err != nil {        fmt.Println(&quot;error:&quot;, err)    }    os.Stdout.Write(b)}// Field appears in JSON as key &quot;myName&quot;.Name string `json:&quot;MyName&quot;`// output//{&quot;ID&quot;:1,&quot;MyName&quot;:&quot;Reds&quot;,&quot;Colors&quot;:[&quot;Crimson&quot;,&quot;Red&quot;,&quot;Ruby&quot;,&quot;Maroon&quot;]}// Field appears in JSON as key &quot;myName&quot; and// the field is omitted from the object if its value is empty,// as defined above.Name string `json:&quot;MyName,omitempty&quot;`// 将上面Name: &quot;Reds&quot; =&gt; Name: &quot;&quot;// output, 由于使用了omitempty选项，MyName字段被忽略掉// {&quot;ID&quot;:1,&quot;Colors&quot;:[&quot;Crimson&quot;,&quot;Red&quot;,&quot;Ruby&quot;,&quot;Maroon&quot;]}// Field appears in JSON as key &quot;Field&quot; (the default), but// the field is skipped if empty.// Note the leading comma.Name string `json:&quot;,omitempty&quot;`// 将上面Name: &quot;Reds&quot; =&gt; Name: &quot;&quot;//{&quot;ID&quot;:1,&quot;Colors&quot;:[&quot;Crimson&quot;,&quot;Red&quot;,&quot;Ruby&quot;,&quot;Maroon&quot;]}// Field is ignored by this package.//忽略字段Name string `json:&quot;-&quot;`// {&quot;ID&quot;:1,&quot;Colors&quot;:[&quot;Crimson&quot;,&quot;Red&quot;,&quot;Ruby&quot;,&quot;Maroon&quot;]}// Field appears in JSON as key &quot;-&quot;.Name string `json:&quot;-,&quot;`// {&quot;ID&quot;:1,&quot;-&quot;:&quot;Reds&quot;,&quot;Colors&quot;:[&quot;Crimson&quot;,&quot;Red&quot;,&quot;Ruby&quot;,&quot;Maroon&quot;]}</code></pre><p>The “string” option signals that a field is stored as JSON inside a JSON-encoded string. It applies only to fields of string, floating point, integer, or boolean types. This extra level of encoding is sometimes used when communicating with JavaScript programs:</p><p><code>“string”选项表示字段在JSON编码的字符串中存储为JSON。 它仅适用于字符串，浮点，整数或布尔类型的字段。 在与JavaScript程序通信时，有时会使用这种额外的编码级别：</code></p><pre><code>ID int `json:&quot;,string&quot;`//仍然使用上面的例子// 可以看到ID转为&quot;1&quot;//{&quot;ID&quot;:&quot;1&quot;,&quot;Name&quot;:&quot;Reds&quot;,&quot;Colors&quot;:[&quot;Crimson&quot;,&quot;Red&quot;,&quot;Ruby&quot;,&quot;Maroon&quot;]}</code></pre><p>The key name will be used if it’s a non-empty string consisting of only Unicode letters, digits, and ASCII punctuation except quotation marks, backslash, and comma.</p><p><code>如果字段名称是只包含Unicode字母，数字和ASCII标点符号（引号，反斜杠和逗号除外） 的非空字符串，则该字段名将被使用</code></p><p>Anonymous struct fields are usually marshaled as if their inner exported fields were fields in the outer struct, subject to the usual Go visibility rules amended as described in the next paragraph.An anonymous struct field with a name given in its JSON tag is treated as having that name, rather than being anonymous.An anonymous struct field of interface type is treated the same as having that type as its name, rather than being anonymous</p><p><code>匿名结构体字段通常会被编码，就好像它们内部导出的字段是外部结构中的字段一样，受到通常的Go可见性规则的限制，如下一段所述。在其JSON标记中给出名称的匿名结构字段被视为具有该名称，而不是匿名。 接口类型的匿名结构字段的处理方式与将该类型作为其名称相同，而不是匿名。</code></p><pre><code>//将上面的例子改造一下，ColorGroup 增加一个匿名结构体 Rgbtype Rgb struct {    R, G, B int}type ColorGroup struct {        ID     int `json:&quot;,string&quot;`        Name   string        Colors []string        Rgb // 匿名结构体}group := ColorGroup{        1,        &quot;Reds&quot;,        []string{&quot;Crimson&quot;, &quot;Red&quot;, &quot;Ruby&quot;, &quot;Maroon&quot;},        Rgb{50, 50, 50},}// output//{&quot;ID&quot;:&quot;1&quot;,&quot;Name&quot;:&quot;Reds&quot;,&quot;Colors&quot;:[&quot;Crimson&quot;,&quot;Red&quot;,&quot;Ruby&quot;,&quot;Maroon&quot;],&quot;R&quot;:50,&quot;G&quot;:50,&quot;B&quot;:50}type ColorGroup struct {        ID     int `json:&quot;,string&quot;`        Name   string        Colors []string        Rgb `json:&quot;rgb&quot;` // json 重命名选项 }// {&quot;ID&quot;:&quot;1&quot;,&quot;Name&quot;:&quot;Reds&quot;,&quot;Colors&quot;:[&quot;Crimson&quot;,&quot;Red&quot;,&quot;Ruby&quot;,&quot;Maroon&quot;],&quot;rgb&quot;:{&quot;R&quot;:50,&quot;G&quot;:50,&quot;B&quot;:50}}</code></pre><p>The Go visibility rules for struct fields are amended for JSON when deciding which field to marshal or unmarshal. If there are multiple fields at the same level, and that level is the least nested (and would therefore be the nesting level selected by the usual Go rules), the following extra rules apply:</p>]]></content>
    
    <summary type="html">
    
      golang标准库 encoding/json 翻译
    
    </summary>
    
      <category term="技术" scheme="https://www.zhengwenkai.com/categories/tech-notes/"/>
    
    
      <category term="golang" scheme="https://www.zhengwenkai.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>NodeJS path.resolve</title>
    <link href="https://www.zhengwenkai.com/tech-notes/NodeJS-path.resolve-1536666490.html"/>
    <id>https://www.zhengwenkai.com/tech-notes/NodeJS-path.resolve-1536666490.html</id>
    <published>2018-09-11T03:48:10.000Z</published>
    <updated>2019-09-11T03:56:21.730Z</updated>
    
    <content type="html"><![CDATA[<h1 id="path-resolve"><a href="#path-resolve" class="headerlink" title="path.resolve"></a>path.resolve</h1><h3 id="path-resolve-…paths"><a href="#path-resolve-…paths" class="headerlink" title="path.resolve([…paths])"></a>path.resolve([…paths])</h3><ul><li>…paths <string> A sequence of paths or path segments (一系列的路径 or 路径片段)</li><li>Returns: <string> absolute path (函数返回绝对路径).</li></ul><p>The <strong>path.resolve()</strong> method resolves a sequence of paths or path segments into an absolute path.</p><p>The given sequence of paths is processed from right to left （给定的路径被从右往左处理，直到构建出一个绝对路径）</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">path.resolve(<span class="string">'/foo'</span>, <span class="string">'/bar'</span>, <span class="string">'baz'</span>)  </span><br><span class="line"><span class="regexp">//</span> 返回 <span class="regexp">/bar/</span>baz</span><br><span class="line"></span><br><span class="line">path.resolve(<span class="string">'/foo/bar'</span>, <span class="string">'/tmp/file/'</span>);</span><br><span class="line"><span class="regexp">//</span> 返回: <span class="string">'/tmp/file'</span></span><br></pre></td></tr></table></figure><p>If after processing all given path segments an absolute path has not yet been generated, the current working directory is used</p><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">path.resolve('wwwroot', 'static_files/png/', '../gif/image.gif');</span><br><span class="line">// 如果当前工作目录为 /home/myself/<span class="keyword">node</span><span class="title">，</span></span><br><span class="line"><span class="title">// 则返回 '/home</span>/myself/<span class="keyword">node</span><span class="title">/wwwroot</span>/static_files/gif/image.gif'</span><br></pre></td></tr></table></figure><p>The resulting path is normalized and trailing slashes are removed unless the path is resolved to the root directory。 结果路径已被规范化并移除尾部斜杠，除非被解析为根目录</p><p>Zero-length path segments are ignored.</p><p>If no path segments are passed, path.resolve() will return the absolute path of the current working directory.</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">path</span><span class="selector-class">.resolve</span>(<span class="string">''</span>)</span><br><span class="line"><span class="selector-tag">path</span><span class="selector-class">.resolve</span>()</span><br><span class="line"><span class="comment">// /home/xxx  current working directory</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      path.resolve 文档翻译
    
    </summary>
    
      <category term="技术" scheme="https://www.zhengwenkai.com/categories/tech-notes/"/>
    
    
      <category term="nodejs" scheme="https://www.zhengwenkai.com/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>WebRTC学习</title>
    <link href="https://www.zhengwenkai.com/tech-notes/WebRTC-1568201590.html"/>
    <id>https://www.zhengwenkai.com/tech-notes/WebRTC-1568201590.html</id>
    <published>2018-09-11T03:33:10.000Z</published>
    <updated>2019-09-11T03:56:08.769Z</updated>
    
    <content type="html"><![CDATA[<h4 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h4><ul><li><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API," title="Api">API文档</a></p></li><li><p><a href="https://webrtc.github.io/samples/," title="sample">Sample</a></p></li><li><p><a href="https://github.com/rtcweb-wg/mdns-ice-candidates">mdns-ice-candidates</a></p><ul><li><a href="https://rtcweb-wg.github.io/mdns-ice-candidates/draft-ietf-rtcweb-mdns-ice-candidates.html#rfc.section.5.4">Using Multicast DNS to protect privacy when exposing ICE candidates</a></li></ul></li><li><p><a href="https://bugs.webkit.org/show_bug.cgi?id=183201">Support WebRTC in Safari in-app browser</a></p></li></ul><h4 id="什么是WebRTC"><a href="#什么是WebRTC" class="headerlink" title="什么是WebRTC"></a>什么是WebRTC</h4><blockquote><p>WebRTC，名称源自网页即时通信（英语：Web Real-Time Communication）的缩写，是一个支持网页浏览器进行实时语音对话或视频对话的API。</p></blockquote><h4 id="获取内网ip实验"><a href="#获取内网ip实验" class="headerlink" title="获取内网ip实验"></a>获取内网ip实验</h4><blockquote><p>WebRTC 它主要使用一个名为ICE ( Interactive Connectivity Establishment ) 的框架来进行穿透内网，它內部整合了 STUN 与 TURN 协议。</p></blockquote><ul><li><p>STUN ( Session Traversal Utilities for NAT ) 中文为 NAT 对谈穿透程序，它的最主要用处就是帮助在 NAT 內的用戶找到可以连到它的位置。</p></li><li><p>TURN ( Traversal Using Relay NAT )，它也是一种穿透 NAT 的协议，不過它是使用中继的方式来进行，通常都是 STUN 的候选位置都无法连接時，才会使用它。</p></li></ul><blockquote><p>由于我们只需要获取本方的内网ip，其实我们不需要连接到STUN 或者 TURN 服务</p></blockquote><h4 id="流程如下"><a href="#流程如下" class="headerlink" title="流程如下"></a>流程如下</h4><p>1.实例化 peerconnection。</p><p>2.设置监听事件 onicecandidate。</p><p>3.然后创建呼叫createOffer将这个连接实例保存为本地sdp信息，setLocalDescription最后通过服务器向对方发送offer,内容包括己方的sdp信息。</p><p>4.对方 接收到offer发送answer （本实验不需要， 没有实现）。</p><p>5.触发ice事件， 调用之前设置的监听回调函数 向对方发送ice候选者。</p><p>6.获取回调函数中关于本方 ice候选者的address 信息，即我们需要获取输数据。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// javascript</span></span><br><span class="line"><span class="comment">// 创建一个peer Connection</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 正常情况下需要传入一个stun的service配置</span></span><br><span class="line"><span class="keyword">const</span> iceServers = [];</span><br><span class="line">iceServers.push(<span class="built_in">JSON</span>.parse(<span class="string">'&#123;"urls":["stun:stun.l.google.com:19302"],"username":"","credential":""&#125;'</span>));</span><br><span class="line">pc = <span class="keyword">new</span> RTCPeerConnection(iceServers);</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 由于我们其实不需要真的去发送/获取候选信息 所以也可以不传</span></span><br><span class="line">pc = <span class="keyword">new</span> RTCPeerConnection(<span class="literal">null</span>);</span><br><span class="line">   </span><br><span class="line"><span class="comment">// 监听ice事件向对方发送ice候选者，其实也不用发送，只要把有用的本方信息保存即可</span></span><br><span class="line">pc.onicecandidate = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.candidate) &#123;</span><br><span class="line">        <span class="keyword">var</span> c = parseCandidate(event.candidate.candidate);</span><br><span class="line">        <span class="keyword">var</span> ip_regex = <span class="regexp">/([0-9]&#123;1,3&#125;(\.[0-9]&#123;1,3&#125;)&#123;3&#125;)/</span>;</span><br><span class="line">        <span class="keyword">var</span> ip = ip_regex.exec(c.address);</span><br><span class="line">        <span class="keyword">var</span> ip_addr = <span class="string">'unkonw'</span>;</span><br><span class="line">        <span class="keyword">if</span> (ip &amp;&amp; ip[<span class="number">1</span>]) &#123;</span><br><span class="line">            ip_addr = ip[<span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"not support"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (ip_dups[ip_addr] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(ip_addr);</span><br><span class="line">        &#125;</span><br><span class="line">        ip_dups[ip_addr] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// createOffer将这个连接实例保存为本地sdp信息 setLocalDescription最后通过服务器向对方发送offer,内容包括己方的sdp信息</span></span><br><span class="line"><span class="comment">// desc.sdp 可以通过这个查看sdp信息</span></span><br><span class="line"><span class="comment">// offerOptions</span></span><br><span class="line">pc.createOffer(offerOptions).then(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">desc</span>) </span>&#123;</span><br><span class="line">        pc.setLocalDescription(desc);</span><br><span class="line">    &#125;,</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//log error</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      webrtc相关
    
    </summary>
    
      <category term="技术" scheme="https://www.zhengwenkai.com/categories/tech-notes/"/>
    
    
      <category term="javascript" scheme="https://www.zhengwenkai.com/tags/javascript/"/>
    
      <category term="前端" scheme="https://www.zhengwenkai.com/tags/front-end/"/>
    
  </entry>
  
  <entry>
    <title>使用Hexo生成blog</title>
    <link href="https://www.zhengwenkai.com/tech-notes/hexo-create-blog-1536635410.html"/>
    <id>https://www.zhengwenkai.com/tech-notes/hexo-create-blog-1536635410.html</id>
    <published>2018-09-11T03:29:10.000Z</published>
    <updated>2019-09-11T03:32:17.552Z</updated>
    
    <content type="html"><![CDATA[<p>  一直在想这个blog该写一些什么。导致半年过去了什么也没写，发现连hexo都忘了怎么用。于是决定就写hexo用法的作为这个blog的第一篇文章好了。</p><ul><li><p>安装 </p><p>当然首先你得有nodejs和npm。</p></li></ul><ol><li><p>新建一个目录。什么myblog、newblog都行。</p></li><li><p>执行如下命令安装Hexo<br><code>sudo npm install -g hexo</code></p></li><li><p>执行init命令初始化hexo,命令<br><code>hexo init</code></p></li><li><p>生成静态页面<br><code>hexo generate</code> 或者 <code>hexo g</code></p></li><li><p>启动本地服务，进行文章预览调试.<code>hexo server</code><br>浏览器输入<a href="http://localhost:4000。">http://localhost:4000。</a> port 4000 是默认的</p></li></ol><ul><li><p>发布</p><p> 我的blog托管在github上，所以在blog目录的_config.yaml文件配置上github的相关信息。</p></li></ul><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">  <span class="attribute">type</span>: git</span><br><span class="line">  <span class="attribute">repo</span>: <span class="attribute">https</span>:<span class="comment">//github.com/xxxxx/xxxx.github.io.git</span></span><br><span class="line">  <span class="attribute">branch</span>: master</span><br><span class="line">  <span class="attribute">message</span>:</span><br></pre></td></tr></table></figure><p>执行发布<br><code>hexo deploy</code></p>]]></content>
    
    <summary type="html">
    
      hexo生成blog教程
    
    </summary>
    
      <category term="技术" scheme="https://www.zhengwenkai.com/categories/tech-notes/"/>
    
    
      <category term="hexo" scheme="https://www.zhengwenkai.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Aws以及shadowsocket</title>
    <link href="https://www.zhengwenkai.com/tech-notes/shadowsocket_nodejs_aws-1536635410.html"/>
    <id>https://www.zhengwenkai.com/tech-notes/shadowsocket_nodejs_aws-1536635410.html</id>
    <published>2018-09-11T03:10:10.000Z</published>
    <updated>2019-09-11T03:15:11.060Z</updated>
    
    <content type="html"><![CDATA[<p>一直嫌麻烦都是直接买的vpn，最近一直使用的vpn无法使用了，又不想装那种vpn客户端，有人推荐的蓝灯，下载一看觉得太贵了。既然都没有满意的就买一个vps自己搞吧。以前申请过aws，就拿它先练练手了</p><ul><li><p>aws</p><p>  1.直接用以前的账号登陆。如果没有的话可以注册一下</p><p>  2.信用卡是之前就绑定好了，没有的话不知道有没有办法绕过。看过一些文章说是可以用虚拟卡，具体操作可以百度</p><p>  3.进入控制台，选择免费的ec2。目前应该是15G以内的流量免费。是否付费，可以自行选择。不想付费，千万别用超了</p><p>  4.我建了一个ubuntu，安装了npm。</p></li><li><p>shadowsockets 部署</p><p>  1.npm install -g shadowsocks 安装<br>  2.在 /usr/local/lib/node_modules/shadowsocks 目录下可以找到配置文件,我简单配置了一下</p><pre>{  "server":"0.0.0.0",  "server_port":8389,  "local_address":"127.0.0.1",  "local_port":1080,  "password":"myladder123",  "timeout":600,  "method":"aes-256-cfb"}</pre><p>  3.ssserver 启动</p></li><li><p>客户端</p></li></ul><p>找到任何支持shadowsock 的客户端<br>按上面的配置 填入服务器的配置信息链接。不出问题应该就可了</p><blockquote><p>注意的是在aws实例的安全配置需要 配置的入站的端口和ip<br>端口就是你开放给客户端的端口，ip如果自用 可以指定ip。也可以选任意ip</p></blockquote>]]></content>
    
    <summary type="html">
    
      aws使用, shadowsocket安装启动, 客户端配置
    
    </summary>
    
      <category term="技术" scheme="https://www.zhengwenkai.com/categories/tech-notes/"/>
    
    
      <category term="linux" scheme="https://www.zhengwenkai.com/tags/linux/"/>
    
      <category term="nodejs" scheme="https://www.zhengwenkai.com/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>手动安装Zsh</title>
    <link href="https://www.zhengwenkai.com/tech-notes/install_zsh-1536635410.html"/>
    <id>https://www.zhengwenkai.com/tech-notes/install_zsh-1536635410.html</id>
    <published>2018-09-11T03:10:10.000Z</published>
    <updated>2019-09-11T03:15:14.227Z</updated>
    
    <content type="html"><![CDATA[<p>接手一个老旧的项目，只能在开发机上开发。果断给自己安装zsh, 就算是只为了git插件也值得安装。(无root权限)</p><ul><li>下载</li></ul><p><code>wget http://sourceforge.net/projects/zsh/files/zsh/5.0.7/zsh-5.0.7.tar.gz</code></p><ul><li>安装</li></ul><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~<span class="string">/tmp/zsh-5.0.7</span></span><br><span class="line"><span class="string">./configure</span> <span class="params">--prefix=</span>$HOME</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><ul><li>安装 oh my zsh</li></ul><p>自动安装</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O - | sh</span><br></pre></td></tr></table></figure><blockquote><p>我试了自动安装会提示 Zsh is not installed! Please install zsh first!。看了一下安装的sh文件，会搜索 /etc/shells 文件 <code>$(grep /zsh$ /etc/shells | wc -l)</code></p></blockquote><p>手动安装</p><figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">git clone <span class="symbol">git:</span>/<span class="regexp">/github.com/robbyrussell</span><span class="regexp">/oh-my-zsh.git ~/</span>.oh-my-zsh</span><br><span class="line">cp ~<span class="regexp">/.oh-my-zsh/templates</span><span class="regexp">/zshrc.zsh-template ~/</span>.zshrc</span><br></pre></td></tr></table></figure><blockquote><p>最后就是设置成默认的shell。chsh这个命令是不能用了，因为没有root权限，所以只能在 .bash_profile 里面做手脚了。在 .bash_profile里面添加如下内容：<br><code>exec $HOME/bin/zsh -l</code><br>好了现在ssh连接到服务器上就变了zsh了。</p></blockquote><ul><li>安装autojump</li></ul><p>下载</p><p><code>git clone git://github.com/joelthelion/autojump.git</code></p><p>安装</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">进入autojump的目录 执行安装的<span class="keyword">py</span>脚本</span><br><span class="line">./install.<span class="keyword">py</span></span><br></pre></td></tr></table></figure><p>安装完后，按照提示 最后把以下代码加入.zshrc：<br><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="string">[[ -s ~/.autojump/etc/profile.d/autojump.sh ]]</span> &amp;&amp; . ~/.autojump/etc/profile.d/autojump.sh</span><br></pre></td></tr></table></figure></p><p>cd 过一次的目录 下次都可以直接跳转<br>重新打开一个shell窗口，尝试一下吧。</p>]]></content>
    
    <summary type="html">
    
      zsh安装，zsh插件
    
    </summary>
    
      <category term="技术" scheme="https://www.zhengwenkai.com/categories/tech-notes/"/>
    
    
      <category term="shell" scheme="https://www.zhengwenkai.com/tags/shell/"/>
    
      <category term="linux" scheme="https://www.zhengwenkai.com/tags/linux/"/>
    
  </entry>
  
</feed>
